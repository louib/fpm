use flatpak_rs::archive::FlatpakArchiveType;
use flatpak_rs::build_system::FlatpakBuildSystem;
use flatpak_rs::module::FlatpakModule;
use flatpak_rs::source::{FlatpakSource, FlatpakSourceItem, FlatpakSourceType};

use serde::{Deserialize, Serialize};

pub const CRATES_IO_URL: &str = "https://static.crates.io/crates";
pub const DEFAULT_DESTINATION: &str = "cargo/vendor";

#[derive(Clone)]
#[derive(Deserialize)]
#[derive(Serialize)]
#[derive(Debug)]
#[derive(Default)]
pub struct CargoLock {
    pub version: i32,

    pub package: Vec<CargoLockPackage>,
}

#[derive(Clone)]
#[derive(Deserialize)]
#[derive(Serialize)]
#[derive(Debug)]
#[derive(Default)]
#[serde(default)]
pub struct CargoLockPackage {
    pub name: String,
    pub source: String,
    pub checksum: String,
    pub version: String,
    pub dependencies: Vec<String>,
}
impl CargoLockPackage {
    pub fn get_sources(&self) -> Vec<FlatpakSource> {
        if self.source.len() == 0 {
            log::debug!("Cargo package {} has no source. ignoring.", &self.name);
            return vec![];
        }
        if self.checksum.len() == 0 {
            // FIXME should we maybe raise an error here?
            log::debug!("Cargo package {} has no checksum. ignoring.", &self.name);
            return vec![];
        }

        if self.source.starts_with("git+") {
            // FIXME ignoring for now.
            return vec![];
        }

        let mut package_source = FlatpakSource::default();
        package_source.r#type = Some(FlatpakSourceType::Archive);
        package_source.archive_type = Some(FlatpakArchiveType::TarGzip);
        package_source.url = Some(format!(
            "{}/{}/{}-{}.crate",
            CRATES_IO_URL, self.name, self.name, self.version
        ));
        package_source.sha256 = Some(self.checksum.clone());
        package_source.dest = Some(format!("{}/{}-{}", DEFAULT_DESTINATION, self.name, self.version));

        vec![package_source]
    }
}

pub fn get_cargo_module(cargo_lock_manifest: &str) -> FlatpakModule {
    let mut cargo_module = FlatpakModule::default();
    cargo_module.name = "cargo_sources".to_string();
    cargo_module.buildsystem = Some(FlatpakBuildSystem::Simple);
    cargo_module
        .build_commands
        .push("cargo --offline fetch --manifest-path Cargo.toml --verbose".to_string());
    cargo_module
        .build_commands
        .push("cargo --offline build --release --verbose".to_string());
    cargo_module
        .build_commands
        .push("install -Dm755 ./target/debug/".to_string());
    let mut current_cargo_project_source: FlatpakSource = FlatpakSource::default();
    current_cargo_project_source.r#type = Some(FlatpakSourceType::Git);
    current_cargo_project_source.path = Some("./".to_string());
    cargo_module
        .sources
        .push(FlatpakSourceItem::Description(current_cargo_project_source));
    for source in get_sources(cargo_lock_manifest).unwrap() {
        cargo_module.sources.push(FlatpakSourceItem::Description(source));
    }
    cargo_module
}

pub fn get_sources(cargo_lock_manifest: &str) -> Result<Vec<FlatpakSource>, String> {
    let mut sources: Vec<FlatpakSource> = vec![];
    let cargo_lock: CargoLock = match toml::from_str(&cargo_lock_manifest) {
        Ok(c) => c,
        Err(e) => {
            return Err(format!("Failed to parse the Cargo.lock manifest: {}.", e));
        }
    };
    for cargo_package in &cargo_lock.package {
        let new_sources = cargo_package.get_sources();
        for new_source in new_sources {
            sources.push(new_source);
        }
    }

    Ok(sources)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_get_sources() {
        let cargo_lock_manifest: &str = r###"
            # This file is automatically @generated by Cargo.
            # It is not intended for manual editing.
            version = 3

            [[package]]
            name = "aho-corasick"
            version = "0.7.18"
            source = "registry+https://github.com/rust-lang/crates.io-index"
            checksum = "1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f"
            dependencies = [
             "memchr",
            ]

            [[package]]
            name = "atty"
            version = "0.2.14"
            source = "registry+https://github.com/rust-lang/crates.io-index"
            checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
            dependencies = [
             "hermit-abi",
             "libc",
             "winapi",
            ]

            [[package]]
            name = "autocfg"
            version = "1.1.0"
            source = "registry+https://github.com/rust-lang/crates.io-index"
            checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

            [[package]]
            name = "bitflags"
            version = "1.3.2"
            source = "registry+https://github.com/rust-lang/crates.io-index"
            checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

            [[package]]
            name = "cfg-if"
            version = "1.0.0"
            source = "registry+https://github.com/rust-lang/crates.io-index"
            checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
        "###;
        let sources = get_sources(cargo_lock_manifest).unwrap();

        assert_eq!(sources.len(), 5);
    }
}
